package sample.lang2.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import sample.lang.common.behavior.ISmartRef__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.errors.BaseQuickFixProvider;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public class b_pointsTo_opposite_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public b_pointsTo_opposite_NonTypesystemRule() {
  }
  public void applyRule(final SNode b, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    for (SNode bpOut : ListSequence.fromList(SLinkOperations.getChildren(b, MetaAdapterFactory.getContainmentLink(0x669610ca6c43422eL, 0x9f37c5c3511f4ef8L, 0x72082dd37174e48dL, 0x72082dd37174e4aeL, "b_PointsTo")))) {
      SNode target = ISmartRef__BehaviorDescriptor.target_id788btdLtKiq.invoke(SLinkOperations.getTarget(bpOut, MetaAdapterFactory.getContainmentLink(0xc1700382310d4ee1L, 0x9c2a40abb0a5fca3L, 0x72082dd37174e48eL, 0x72082dd37174e48fL, "ref")));
      {
        final SNode at = target;
        if (SNodeOperations.isInstanceOf(at, MetaAdapterFactory.getConcept(0x8216fa52aa014b4dL, 0x94a065b169678b1cL, 0x72082dd37174e48cL, "sample.lang.structure.A"))) {
          boolean existsPointedBy = false;
          for (SNode pa : ListSequence.fromList(SLinkOperations.getChildren(at, MetaAdapterFactory.getContainmentLink(0x8216fa52aa014b4dL, 0x94a065b169678b1cL, 0x72082dd37174e48cL, 0x72082dd37174e4d0L, "pointedBy_b")))) {
            existsPointedBy |= SLinkOperations.getTarget(pa, MetaAdapterFactory.getReferenceLink(0xc1700382310d4ee1L, 0x9c2a40abb0a5fca3L, 0x72082dd37174e4b9L, 0x72082dd3717533f9L, "inref")) == bpOut;
          }
          if (!(existsPointedBy)) {
            {
              MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(bpOut, "missing opposite -", "r:0a03989f-dde8-4139-b84d-c31ac8120e84(sample.lang2.typesystem)", "8216867906302608872", null, errorTarget);
              {
                BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("sample.lang.common.typesystem.fix_pto_QuickFix", true);
                intentionProvider.putArgument("p", bpOut);
                _reporter_2309309498.addIntentionProvider(intentionProvider);
              }
            }
            {
              MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(at, "missing opposite for pointer: " + SPropertyOperations.getString(bpOut, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), "r:0a03989f-dde8-4139-b84d-c31ac8120e84(sample.lang2.typesystem)", "8216867906302608875", null, errorTarget);
            }
          }
        }
      }
      {
        final SNode bt = target;
        if (SNodeOperations.isInstanceOf(bt, MetaAdapterFactory.getConcept(0x669610ca6c43422eL, 0x9f37c5c3511f4ef8L, 0x72082dd37174e48dL, "sample.lang2.structure.B"))) {
          boolean existsPointedBy = false;
          for (SNode pa : ListSequence.fromList(SLinkOperations.getChildren(bt, MetaAdapterFactory.getContainmentLink(0x669610ca6c43422eL, 0x9f37c5c3511f4ef8L, 0x72082dd37174e48dL, 0x72082dd37174e4c0L, "pointedBy_b")))) {
            existsPointedBy |= SLinkOperations.getTarget(pa, MetaAdapterFactory.getReferenceLink(0xc1700382310d4ee1L, 0x9c2a40abb0a5fca3L, 0x72082dd37174e4b9L, 0x72082dd3717533f9L, "inref")) == bpOut;
          }
          if (!(existsPointedBy)) {
            {
              MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(bpOut, "missing opposite -", "r:0a03989f-dde8-4139-b84d-c31ac8120e84(sample.lang2.typesystem)", "8216867906302608909", null, errorTarget);
              {
                BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("sample.lang.common.typesystem.fix_pto_QuickFix", true);
                intentionProvider.putArgument("p", bpOut);
                _reporter_2309309498.addIntentionProvider(intentionProvider);
              }
            }
            {
              MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(bt, "missing opposite for pointer: " + SPropertyOperations.getString(bpOut, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), "r:0a03989f-dde8-4139-b84d-c31ac8120e84(sample.lang2.typesystem)", "8216867906302608912", null, errorTarget);
            }
          }
        }
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return MetaAdapterFactory.getConcept(0x669610ca6c43422eL, 0x9f37c5c3511f4ef8L, 0x72082dd37174e48dL, "sample.lang2.structure.B");
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }
}
